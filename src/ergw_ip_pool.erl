%% Copyright 2015-2020, Travelping GmbH <info@travelping.com>

%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version
%% 2 of the License, or (at your option) any later version.

-module(ergw_ip_pool).

%% API
-export([start_ip_pool/2, send_request/2, wait_response/1, release/1,
	 addr/1, ip/1, opts/1]).
-export([static_ip/2]).
-export([validate_options/1, validate_name/2, config_meta/0]).

-if(?OTP_RELEASE =< 23).
-ignore_xref([behaviour_info/1]).
-endif.

-include_lib("kernel/include/logger.hrl").

-define(IS_IPv4(X), (is_tuple(X) andalso tuple_size(X) == 4)).
-define(IS_IPv6(X), (is_tuple(X) andalso tuple_size(X) == 8)).

%%====================================================================
%% Behavior spec
%%====================================================================

-callback start_ip_pool(Name :: binary(), Opts :: map()) -> Result :: term().
-callback send_pool_request(CliendId :: term(), Request :: term()) -> ReqId :: term().
-callback wait_pool_response(ReqId :: term()) -> Result :: term().
-callback ip(AllocInfo :: tuple()) -> Result :: term().
-callback opts(AllocInfo :: tuple()) -> Result :: term().
-callback release(AllocInfo :: tuple()) -> Result :: term().

%%====================================================================
%% API
%%====================================================================

start_ip_pool(Name, Opts) ->
    with_pool(Name, fun(Handler) -> apply(Handler, ?FUNCTION_NAME, [Name, Opts]) end).

send_request(ClientId, Requests) ->
    [send_pool_request(ClientId, R) || R <- Requests].

wait_response(RequestIds) ->
    [wait_pool_response(R) || R <- RequestIds].

release(AllocInfos) ->
    [pool_release(AI) || AI <- AllocInfos].

addr(AllocInfo) ->
    case ip(AllocInfo) of
	{IP, _} -> IP;
	Other -> Other
    end.

ip(AllocInfo) ->
    alloc_info(AllocInfo, ip).

opts(AllocInfo) ->
    alloc_info(AllocInfo, opts).

static_ip(IP, PrefixLen) ->
    {'$static', {IP, PrefixLen}}.

%%%====================================================================
%%% Options Validation
%%%===================================================================

validate_options(Options) ->
    ?LOG(debug, "IP Pool Options: ~p", [Options]),
    case ergw_config_legacy:get_opt(handler, Options, ergw_local_pool) of
	ergw_local_pool ->
	    ergw_local_pool:validate_options(Options);
	Handler ->
	    throw({error, {options, {handler, Handler}}})
    end.

validate_name(_, Name) when is_binary(Name); is_list(Name); is_atom(Name) ->
    ergw_config:to_binary(Name);
validate_name(Opt, Name) ->
   throw({error, {options, {Opt, Name}}}).

config_meta() ->
    Range = #{
	      start => ip,
	      'end' => ip,
	      prefixLen => integer
	     },
    Meta = #{handler                    => module,
	     ranges                     => {list, Range},
	     'MS-Primary-DNS-Server'    => ip4,
	     'MS-Secondary-DNS-Server'  => ip4,
	     'MS-Primary-NBNS-Server'   => ip4,
	     'MS-Secondary-NBNS-Server' => ip4,
	     'DNS-Server-IPv6-Address'  => {list, ip6},    %tbd
	     '3GPP-IPv6-DNS-Servers'    => {list, ip6}},   %tbd
    {{map, {id, binary}, Meta}, #{}}.


%%%===================================================================
%%% Internal functions
%%%===================================================================

alloc_info(Info, F) when element(1, Info) =:= '$static' ->
    static_ip_info(F, Info);
alloc_info(Tuple, F) when is_tuple(Tuple) ->
    apply(element(1, Tuple), F, [Tuple]);
alloc_info(_, _) ->
    undefined.

static_ip_info(ip, {_, Addr}) -> Addr;
static_ip_info(opts,   _) -> #{};
static_ip_info(release, _) -> ok.

with_pool(Pool, Fun) ->
    case application:get_env(ip_pools) of
	{ok, #{Pool := #{handler := Handler}}} ->
	    Fun(Handler);
	_ ->
	    {error, not_found}
    end.

send_pool_request(_ClientId, skip) ->
    skip;
send_pool_request(ClientId, {Pool, _, _, _} = Req) ->
    with_pool(Pool, fun(Handler) -> {Handler, apply(Handler, ?FUNCTION_NAME, [ClientId, Req])} end).

wait_pool_response(skip) ->
    skip;
wait_pool_response({error, _Reason} = Error) ->
    Error;
wait_pool_response({Handler, ReqId}) ->
    Handler:wait_pool_response(ReqId).

pool_release(AI) ->
    alloc_info(AI, release).
